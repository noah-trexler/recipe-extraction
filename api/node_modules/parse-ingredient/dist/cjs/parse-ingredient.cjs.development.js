"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  defaultOptions: () => defaultOptions,
  firstWordRegEx: () => firstWordRegEx,
  fors: () => fors,
  forsRegEx: () => forsRegEx,
  ofRegEx: () => ofRegEx,
  ofs: () => ofs,
  parseIngredient: () => parseIngredient,
  rangeSeparatorRegEx: () => rangeSeparatorRegEx,
  rangeSeparatorWords: () => rangeSeparatorWords,
  unitsOfMeasure: () => unitsOfMeasure
});
module.exports = __toCommonJS(src_exports);

// src/parseIngredient.ts
var import_numeric_quantity = require("numeric-quantity");

// src/constants.ts
var defaultOptions = {
  additionalUOMs: {},
  allowLeadingOf: false,
  normalizeUOM: false
};
var fors = ["For"];
var forsRegEx = new RegExp(`^(?:${fors.join("|")})\\s`, "i");
var rangeSeparatorWords = ["or", "to"];
var rangeSeparatorRegEx = new RegExp(
  `^(-|\u2013|\u2014|(?:${rangeSeparatorWords.join("|")})\\s)`,
  "i"
);
var firstWordRegEx = /^(fl(?:uid)?(?:\s+|-)(?:oz|ounces?)|\w+[-.]?)(.+)?/;
var ofs = ["of"];
var ofRegEx = new RegExp(`^(?:${ofs.join("|")})\\s+`, "i");
var unitsOfMeasure = {
  bag: { short: "bag", plural: "bags", alternates: [] },
  box: { short: "box", plural: "boxes", alternates: [] },
  bunch: { short: "bunch", plural: "bunches", alternates: [] },
  can: { short: "can", plural: "cans", alternates: [] },
  carton: { short: "carton", plural: "cartons", alternates: [] },
  centimeter: { short: "cm", plural: "centimeters", alternates: ["cm."] },
  clove: { short: "clove", plural: "cloves", alternates: [] },
  container: { short: "container", plural: "containers", alternates: [] },
  cup: { short: "c", plural: "cups", alternates: ["c.", "C"] },
  dash: { short: "dash", plural: "dashes", alternates: [] },
  drop: { short: "drop", plural: "drops", alternates: [] },
  ear: { short: "ear", plural: "ears", alternates: [] },
  "fluid ounce": { short: "fl oz", plural: "fluid ounces", alternates: ["fluidounce", "floz", "fl-oz", "fluid-ounce", "fluid-ounces", "fluidounces", "fl ounce", "fl ounces", "fl-ounce", "fl-ounces", "fluid oz", "fluid-oz"] },
  // prettier-ignore
  foot: { short: "ft", plural: "feet", alternates: ["ft."] },
  gallon: { short: "gal", plural: "gallons", alternates: ["gal."] },
  gram: { short: "g", plural: "grams", alternates: ["g."] },
  head: { short: "head", plural: "heads", alternates: [] },
  inch: { short: "in", plural: "inches", alternates: ["in."] },
  kilogram: { short: "kg", plural: "kilograms", alternates: ["kg."] },
  large: { short: "lg", plural: "large", alternates: ["lg", "lg."] },
  liter: { short: "l", plural: "liters", alternates: [] },
  medium: { short: "md", plural: "medium", alternates: ["med", "med.", "md."] },
  meter: { short: "m", plural: "meters", alternates: ["m."] },
  milligram: { short: "mg", plural: "milligrams", alternates: ["mg."] },
  milliliter: { short: "ml", plural: "milliliters", alternates: ["mL", "ml.", "mL."] },
  millimeter: { short: "mm", plural: "millimeters", alternates: ["mm."] },
  ounce: { short: "oz", plural: "ounces", alternates: ["oz."] },
  pack: { short: "pack", plural: "packs", alternates: [] },
  package: { short: "pkg", plural: "packages", alternates: ["pkg.", "pkgs"] },
  piece: { short: "piece", plural: "pieces", alternates: ["pcs", "pcs."] },
  pinch: { short: "pinch", plural: "pinches", alternates: [] },
  pint: { short: "pt", plural: "pints", alternates: ["pt."] },
  pound: { short: "lb", plural: "pounds", alternates: ["lb.", "lbs", "lbs."] },
  quart: { short: "qt", plural: "quarts", alternates: ["qt.", "qts", "qts."] },
  small: { short: "sm", plural: "small", alternates: ["sm."] },
  sprig: { short: "sprig", plural: "sprigs", alternates: [] },
  stick: { short: "stick", plural: "sticks", alternates: [] },
  tablespoon: { short: "tbsp", plural: "tablespoons", alternates: ["tbsp.", "T", "Tbsp."] },
  teaspoon: { short: "tsp", plural: "teaspoons", alternates: ["tsp.", "t"] },
  yard: { short: "yd", plural: "yards", alternates: ["yd.", "yds."] }
};

// src/utils.ts
var compactStringArray = (array) => {
  let index = -1;
  const length = array.length;
  let resIndex = 0;
  const result = [];
  while (++index < length) {
    const value = array[index].trim();
    if (value) {
      result[resIndex++] = value;
    }
  }
  return result;
};

// src/parseIngredient.ts
var newLineRegExp = /\r?\n/;
var addIdToUomDefinition = ([uom, def]) => ({ id: uom, ...def });
var parseIngredient = (ingText, options = defaultOptions) => {
  const opts = { ...defaultOptions, ...options };
  const mergedUOMs = { ...unitsOfMeasure, ...opts.additionalUOMs };
  const uomArray = Object.entries(mergedUOMs).map(addIdToUomDefinition);
  const uomArrayLength = uomArray.length;
  return compactStringArray(ingText.split(newLineRegExp)).map((line) => {
    const oIng = {
      quantity: null,
      quantity2: null,
      unitOfMeasureID: null,
      unitOfMeasure: null,
      description: "",
      isGroupHeader: false
    };
    const nqResultFirstChar = (0, import_numeric_quantity.numericQuantity)(line.substring(0, 1));
    if (isNaN(nqResultFirstChar)) {
      oIng.description = line;
      if (oIng.description.endsWith(":") || forsRegEx.test(oIng.description)) {
        oIng.isGroupHeader = true;
      }
    } else {
      let lenNum = 6;
      let nqResult = NaN;
      while (lenNum > 0 && isNaN(nqResult)) {
        nqResult = (0, import_numeric_quantity.numericQuantity)(line.substring(0, lenNum).trim());
        if (nqResult > -1) {
          oIng.quantity = nqResult;
          oIng.description = line.substring(lenNum).trim();
        }
        lenNum--;
      }
    }
    const q2reMatch = rangeSeparatorRegEx.exec(oIng.description);
    if (q2reMatch) {
      const q2reMatchLen = q2reMatch[1].length;
      const nqResultFirstChar2 = (0, import_numeric_quantity.numericQuantity)(oIng.description.substring(q2reMatchLen).trim()[0]);
      if (!isNaN(nqResultFirstChar2)) {
        let lenNum = 7;
        let nqResult = NaN;
        while (--lenNum > 0 && isNaN(nqResult)) {
          nqResult = (0, import_numeric_quantity.numericQuantity)(oIng.description.substring(q2reMatchLen, lenNum));
          if (!isNaN(nqResult)) {
            oIng.quantity2 = nqResult;
            oIng.description = oIng.description.substring(lenNum).trim();
          }
        }
      }
    }
    const firstWordREMatches = firstWordRegEx.exec(oIng.description);
    if (firstWordREMatches) {
      const firstWord = firstWordREMatches[1].replace(/\s+/g, " ");
      const remainingDesc = (firstWordREMatches[2] ?? "").trim();
      if (remainingDesc) {
        let uom = "";
        let uomID = "";
        let i = -1;
        while (++i < uomArrayLength && !uom) {
          const { alternates, id, short, plural } = uomArray[i];
          const versions = [...alternates, id, short, plural];
          if (versions.includes(firstWord)) {
            uom = firstWord;
            uomID = id;
          }
        }
        if (uom) {
          oIng.unitOfMeasureID = uomID;
          oIng.unitOfMeasure = opts.normalizeUOM ? uomID : uom;
          oIng.description = remainingDesc;
        }
      }
    }
    if (!opts.allowLeadingOf && oIng.description.match(ofRegEx)) {
      oIng.description = oIng.description.replace(ofRegEx, "");
    }
    return oIng;
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  defaultOptions,
  firstWordRegEx,
  fors,
  forsRegEx,
  ofRegEx,
  ofs,
  parseIngredient,
  rangeSeparatorRegEx,
  rangeSeparatorWords,
  unitsOfMeasure
});
//# sourceMappingURL=parse-ingredient.cjs.development.js.map