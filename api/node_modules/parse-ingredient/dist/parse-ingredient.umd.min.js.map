{"version":3,"sources":["../src/index.ts","../node_modules/numeric-quantity/src/constants.ts","../node_modules/numeric-quantity/src/parseRomanNumerals.ts","../node_modules/numeric-quantity/src/numericQuantity.ts","../src/constants.ts","../src/utils.ts","../src/parseIngredient.ts"],"sourcesContent":["export * from './parseIngredient';\nexport * from './constants';\nexport * from './types';\n","import type {\n  NumericQuantityOptions,\n  RomanNumeralAscii,\n  RomanNumeralUnicode,\n  VulgarFraction,\n} from './types';\n\n// #region Arabic numerals\n/**\n * Map of Unicode fraction code points to their ASCII equivalents\n */\nexport const vulgarFractionToAsciiMap: Record<VulgarFraction, string> = {\n  '¼': '1/4',\n  '½': '1/2',\n  '¾': '3/4',\n  '⅐': '1/7',\n  '⅑': '1/9',\n  '⅒': '1/10',\n  '⅓': '1/3',\n  '⅔': '2/3',\n  '⅕': '1/5',\n  '⅖': '2/5',\n  '⅗': '3/5',\n  '⅘': '4/5',\n  '⅙': '1/6',\n  '⅚': '5/6',\n  '⅛': '1/8',\n  '⅜': '3/8',\n  '⅝': '5/8',\n  '⅞': '7/8',\n  '⅟': '1/',\n};\n\n/**\n * Captures the individual elements of a numeric string.\n *\n * Capture groups:\n *\n *     +=====+====================+========================+\n *     |  #  |    Description     |        Example         |\n *     +=====+====================+========================+\n *     |  0  |  entire string     |  \"2 1/3\" from \"2 1/3\"  |\n *     +-----+--------------------+------------------------+\n *     |  1  |  \"negative\" dash   |  \"-\" from \"-2 1/3\"     |\n *     +-----+--------------------+------------------------+\n *     |  2  |  the whole number  |  \"2\" from \"2 1/3\"      |\n *     |     |  - OR -            |                        |\n *     |     |  the numerator     |  \"1\" from \"1/3\"        |\n *     |     +                    +                        |\n *     | (This may include comma/underscore separators)    |\n *     +-----+--------------------+------------------------+\n *     |  3  |  entire fraction   |  \" 1/3\" from \"2 1/3\"   |\n *     |     |  - OR -            |                        |\n *     |     |  decimal portion   |  \".33\" from \"2.33\"     |\n *     |     |  - OR -            |                        |\n *     |     |  denominator       |  \"/3\" from \"1/3\"       |\n *     +=====+====================+========================+\n *\n * @example\n *     numericRegex.exec(\"1\")     // [ \"1\",     \"1\", null,   null ]\n *     numericRegex.exec(\"1.23\")  // [ \"1.23\",  \"1\", \".23\",  null ]\n *     numericRegex.exec(\"1 2/3\") // [ \"1 2/3\", \"1\", \" 2/3\", \" 2\" ]\n *     numericRegex.exec(\"2/3\")   // [ \"2/3\",   \"2\", \"/3\",   null ]\n *     numericRegex.exec(\"2 / 3\") // [ \"2 / 3\", \"2\", \"/ 3\",  null ]\n */\nexport const numericRegex =\n  /^(?=-?\\s*\\.\\d|-?\\s*\\d)(-)?\\s*((?:\\d(?:[\\d,_]*\\d)?)*)(([eE][+-]?\\d(?:[\\d,_]*\\d)?)?|\\.\\d(?:[\\d,_]*\\d)?([eE][+-]?\\d(?:[\\d,_]*\\d)?)?|(\\s+\\d(?:[\\d,_]*\\d)?\\s*)?\\s*\\/\\s*\\d(?:[\\d,_]*\\d)?)?$/;\n/**\n * Same as `numericRegex`, but allows/ignores trailing invalid characters.\n */\nexport const numericRegexWithTrailingInvalid =\n  /^(?=-?\\s*\\.\\d|-?\\s*\\d)(-)?\\s*((?:\\d(?:[\\d,_]*\\d)?)*)(([eE][+-]?\\d(?:[\\d,_]*\\d)?)?|\\.\\d(?:[\\d,_]*\\d)?([eE][+-]?\\d(?:[\\d,_]*\\d)?)?|(\\s+\\d(?:[\\d,_]*\\d)?\\s*)?\\s*\\/\\s*\\d(?:[\\d,_]*\\d)?)?(?:\\s*[^\\.\\d\\/].*)?/;\n\n/**\n * Captures any Unicode vulgar fractions\n */\nexport const vulgarFractionsRegex = new RegExp(\n  `(${Object.keys(vulgarFractionToAsciiMap).join('|')})`\n);\n// #endregion\n\n// #region Roman numerals\ntype RomanNumeralSequenceFragment =\n  | `${RomanNumeralAscii}`\n  | `${RomanNumeralAscii}${RomanNumeralAscii}`\n  | `${RomanNumeralAscii}${RomanNumeralAscii}${RomanNumeralAscii}`\n  | `${RomanNumeralAscii}${RomanNumeralAscii}${RomanNumeralAscii}${RomanNumeralAscii}`;\n\nexport const romanNumeralValues = {\n  MMM: 3000,\n  MM: 2000,\n  M: 1000,\n  CM: 900,\n  DCCC: 800,\n  DCC: 700,\n  DC: 600,\n  D: 500,\n  CD: 400,\n  CCC: 300,\n  CC: 200,\n  C: 100,\n  XC: 90,\n  LXXX: 80,\n  LXX: 70,\n  LX: 60,\n  L: 50,\n  XL: 40,\n  XXX: 30,\n  XX: 20,\n  // Twelve is only here for tests; not used in practice\n  XII: 12,\n  // Eleven is only here for tests; not used in practice\n  XI: 11,\n  X: 10,\n  IX: 9,\n  VIII: 8,\n  VII: 7,\n  VI: 6,\n  V: 5,\n  IV: 4,\n  III: 3,\n  II: 2,\n  I: 1,\n} satisfies { [k in RomanNumeralSequenceFragment]?: number };\n\n/**\n * Map of Unicode Roman numeral code points to their ASCII equivalents\n */\nexport const romanNumeralUnicodeToAsciiMap: Record<\n  RomanNumeralUnicode,\n  keyof typeof romanNumeralValues\n> = {\n  // Roman Numeral One (U+2160)\n  Ⅰ: 'I',\n  // Roman Numeral Two (U+2161)\n  Ⅱ: 'II',\n  // Roman Numeral Three (U+2162)\n  Ⅲ: 'III',\n  // Roman Numeral Four (U+2163)\n  Ⅳ: 'IV',\n  // Roman Numeral Five (U+2164)\n  Ⅴ: 'V',\n  // Roman Numeral Six (U+2165)\n  Ⅵ: 'VI',\n  // Roman Numeral Seven (U+2166)\n  Ⅶ: 'VII',\n  // Roman Numeral Eight (U+2167)\n  Ⅷ: 'VIII',\n  // Roman Numeral Nine (U+2168)\n  Ⅸ: 'IX',\n  // Roman Numeral Ten (U+2169)\n  Ⅹ: 'X',\n  // Roman Numeral Eleven (U+216A)\n  Ⅺ: 'XI',\n  // Roman Numeral Twelve (U+216B)\n  Ⅻ: 'XII',\n  // Roman Numeral Fifty (U+216C)\n  Ⅼ: 'L',\n  // Roman Numeral One Hundred (U+216D)\n  Ⅽ: 'C',\n  // Roman Numeral Five Hundred (U+216E)\n  Ⅾ: 'D',\n  // Roman Numeral One Thousand (U+216F)\n  Ⅿ: 'M',\n  // Small Roman Numeral One (U+2170)\n  ⅰ: 'I',\n  // Small Roman Numeral Two (U+2171)\n  ⅱ: 'II',\n  // Small Roman Numeral Three (U+2172)\n  ⅲ: 'III',\n  // Small Roman Numeral Four (U+2173)\n  ⅳ: 'IV',\n  // Small Roman Numeral Five (U+2174)\n  ⅴ: 'V',\n  // Small Roman Numeral Six (U+2175)\n  ⅵ: 'VI',\n  // Small Roman Numeral Seven (U+2176)\n  ⅶ: 'VII',\n  // Small Roman Numeral Eight (U+2177)\n  ⅷ: 'VIII',\n  // Small Roman Numeral Nine (U+2178)\n  ⅸ: 'IX',\n  // Small Roman Numeral Ten (U+2179)\n  ⅹ: 'X',\n  // Small Roman Numeral Eleven (U+217A)\n  ⅺ: 'XI',\n  // Small Roman Numeral Twelve (U+217B)\n  ⅻ: 'XII',\n  // Small Roman Numeral Fifty (U+217C)\n  ⅼ: 'L',\n  // Small Roman Numeral One Hundred (U+217D)\n  ⅽ: 'C',\n  // Small Roman Numeral Five Hundred (U+217E)\n  ⅾ: 'D',\n  // Small Roman Numeral One Thousand (U+217F)\n  ⅿ: 'M',\n};\n\n/**\n * Captures all Unicode Roman numeral code points\n */\nexport const romanNumeralUnicodeRegex = new RegExp(\n  `(${Object.keys(romanNumeralUnicodeToAsciiMap).join('|')})`,\n  'gi'\n);\n\n/**\n * Captures a valid Roman numeral sequence\n *\n * Capture groups:\n *\n *     +=====+=================+==========================+\n *     |  #  |   Description   |         Example          |\n *     +=====+=================+==========================+\n *     |  0  |  Entire string  |  \"MCCXIV\" from \"MCCXIV\"  |\n *     +-----+-----------------+--------------------------+\n *     |  1  |  Thousands      |  \"M\" from \"MCCXIV\"       |\n *     +-----+-----------------+--------------------------+\n *     |  2  |  Hundreds       |  \"CC\" from \"MCCXIV\"      |\n *     +-----+-----------------+--------------------------+\n *     |  3  |  Tens           |  \"X\" from \"MCCXIV\"       |\n *     +-----+-----------------+--------------------------+\n *     |  4  |  Ones           |  \"IV\" from \"MCCXIV\"      |\n *     +=====+=================+==========================+\n *\n * @example\n *     romanNumeralRegex.exec(\"M\")      // [      \"M\", \"M\",   \"\",  \"\",   \"\" ]\n *     romanNumeralRegex.exec(\"XII\")    // [    \"XII\",  \"\",   \"\", \"X\", \"II\" ]\n *     romanNumeralRegex.exec(\"MCCXIV\") // [ \"MCCXIV\", \"M\", \"CC\", \"X\", \"IV\" ]\n */\nexport const romanNumeralRegex =\n  /^(?=[MDCLXVI])(M{0,3})(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$/i;\n// #endregion\n\nexport const defaultOptions = {\n  round: 3,\n  allowTrailingInvalid: false,\n  romanNumerals: false,\n} satisfies Required<NumericQuantityOptions>;\n","import {\n  romanNumeralRegex,\n  romanNumeralUnicodeRegex,\n  romanNumeralUnicodeToAsciiMap,\n  romanNumeralValues,\n} from './constants';\n\n// Just a shorthand type alias\ntype RNV = keyof typeof romanNumeralValues;\n\n/**\n * Converts a string of Roman numerals to a number, like `parseInt`\n * for Roman numerals. Uses modern, strict rules (only 1 to 3999).\n *\n * The string can include ASCII representations of Roman numerals\n * or Unicode Roman numeral code points (`U+2160` through `U+217F`).\n */\nexport const parseRomanNumerals = (romanNumerals: string) => {\n  const normalized = `${romanNumerals}`\n    // Convert Unicode Roman numerals to ASCII\n    .replace(\n      romanNumeralUnicodeRegex,\n      (_m, rn: keyof typeof romanNumeralUnicodeToAsciiMap) =>\n        romanNumeralUnicodeToAsciiMap[rn]\n    )\n    // Normalize to uppercase (more common for Roman numerals)\n    .toUpperCase();\n\n  const regexResult = romanNumeralRegex.exec(normalized);\n\n  if (!regexResult) {\n    return NaN;\n  }\n\n  const [, thousands, hundreds, tens, ones] = regexResult;\n\n  return (\n    (romanNumeralValues[thousands as RNV] ?? 0) +\n    (romanNumeralValues[hundreds as RNV] ?? 0) +\n    (romanNumeralValues[tens as RNV] ?? 0) +\n    (romanNumeralValues[ones as RNV] ?? 0)\n  );\n};\n","import {\n  defaultOptions,\n  numericRegex,\n  numericRegexWithTrailingInvalid,\n  vulgarFractionToAsciiMap,\n  vulgarFractionsRegex,\n} from './constants';\nimport { parseRomanNumerals } from './parseRomanNumerals';\nimport type { NumericQuantityOptions } from './types';\n\nconst spaceThenSlashRegex = /^\\s*\\//;\n\n/**\n * Converts a string to a number, like an enhanced version of `parseFloat`.\n *\n * The string can include mixed numbers, vulgar fractions, or Roman numerals.\n */\nexport const numericQuantity = (\n  quantity: string | number,\n  options: NumericQuantityOptions = defaultOptions\n) => {\n  if (typeof quantity === 'number' || typeof quantity === 'bigint') {\n    return quantity;\n  }\n\n  let finalResult = NaN;\n\n  // Coerce to string in case qty is a number\n  const quantityAsString = `${quantity}`\n    // Convert vulgar fractions to ASCII, with a leading space\n    // to keep the whole number and the fraction separate\n    .replace(\n      vulgarFractionsRegex,\n      (_m, vf: keyof typeof vulgarFractionToAsciiMap) =>\n        ` ${vulgarFractionToAsciiMap[vf]}`\n    )\n    // Convert fraction slash to standard slash\n    .replace('⁄', '/')\n    .trim();\n\n  // Bail out if the string was only white space\n  if (quantityAsString.length === 0) {\n    return NaN;\n  }\n\n  const opts: Required<NumericQuantityOptions> = {\n    ...defaultOptions,\n    ...options,\n  };\n\n  const regexResult = (\n    opts.allowTrailingInvalid ? numericRegexWithTrailingInvalid : numericRegex\n  ).exec(quantityAsString);\n\n  // If the Arabic numeral regex fails, try Roman numerals\n  if (!regexResult) {\n    return opts.romanNumerals ? parseRomanNumerals(quantityAsString) : NaN;\n  }\n\n  const [, dash, ng1temp, ng2temp] = regexResult;\n  const numberGroup1 = ng1temp.replace(/[,_]/g, '');\n  const numberGroup2 = ng2temp?.replace(/[,_]/g, '');\n\n  // Numerify capture group 1\n  if (!numberGroup1 && numberGroup2 && numberGroup2.startsWith('.')) {\n    finalResult = 0;\n  } else {\n    finalResult = parseInt(numberGroup1);\n  }\n\n  // If capture group 2 is null, then we're dealing with an integer\n  // and there is nothing left to process\n  if (!numberGroup2) {\n    return dash ? finalResult * -1 : finalResult;\n  }\n\n  const roundingFactor =\n    opts.round === false\n      ? NaN\n      : parseFloat(`1e${Math.floor(Math.max(0, opts.round))}`);\n\n  if (\n    numberGroup2.startsWith('.') ||\n    numberGroup2.startsWith('e') ||\n    numberGroup2.startsWith('E')\n  ) {\n    // If first char of `numberGroup2` is \".\" or \"e\"/\"E\", it's a decimal\n    const decimalValue = parseFloat(`${finalResult}${numberGroup2}`);\n    finalResult = isNaN(roundingFactor)\n      ? decimalValue\n      : Math.round(decimalValue * roundingFactor) / roundingFactor;\n  } else if (spaceThenSlashRegex.test(numberGroup2)) {\n    // If the first non-space char is \"/\" it's a pure fraction (e.g. \"1/2\")\n    const numerator = parseInt(numberGroup1);\n    const denominator = parseInt(numberGroup2.replace('/', ''));\n    finalResult = isNaN(roundingFactor)\n      ? numerator / denominator\n      : Math.round((numerator * roundingFactor) / denominator) / roundingFactor;\n  } else {\n    // Otherwise it's a mixed fraction (e.g. \"1 2/3\")\n    const fractionArray = numberGroup2.split('/');\n    const [numerator, denominator] = fractionArray.map(v => parseInt(v));\n    finalResult += isNaN(roundingFactor)\n      ? numerator / denominator\n      : Math.round((numerator * roundingFactor) / denominator) / roundingFactor;\n  }\n\n  return dash ? finalResult * -1 : finalResult;\n};\n","import { ParseIngredientOptions, UnitOfMeasureDefinitions } from './types';\n\nexport const defaultOptions = {\n  additionalUOMs: {},\n  allowLeadingOf: false,\n  normalizeUOM: false,\n} satisfies Required<ParseIngredientOptions>;\n\nexport const fors = ['For'] as const;\nexport const forsRegEx = new RegExp(`^(?:${fors.join('|')})\\\\s`, 'i');\n\nexport const rangeSeparatorWords = ['or', 'to'] as const;\nexport const rangeSeparatorRegEx = new RegExp(\n  `^(-|–|—|(?:${rangeSeparatorWords.join('|')})\\\\s)`,\n  'i'\n);\n\nexport const firstWordRegEx = /^(fl(?:uid)?(?:\\s+|-)(?:oz|ounces?)|\\w+[-.]?)(.+)?/;\n\nexport const ofs = ['of'] as const;\nexport const ofRegEx = new RegExp(`^(?:${ofs.join('|')})\\\\s+`, 'i');\n\nexport const unitsOfMeasure = {\n  bag: { short: 'bag', plural: 'bags', alternates: [] },\n  box: { short: 'box', plural: 'boxes', alternates: [] },\n  bunch: { short: 'bunch', plural: 'bunches', alternates: [] },\n  can: { short: 'can', plural: 'cans', alternates: [] },\n  carton: { short: 'carton', plural: 'cartons', alternates: [] },\n  centimeter: { short: 'cm', plural: 'centimeters', alternates: ['cm.'] },\n  clove: { short: 'clove', plural: 'cloves', alternates: [] },\n  container: { short: 'container', plural: 'containers', alternates: [] },\n  cup: { short: 'c', plural: 'cups', alternates: ['c.', 'C'] },\n  dash: { short: 'dash', plural: 'dashes', alternates: [] },\n  drop: { short: 'drop', plural: 'drops', alternates: [] },\n  ear: { short: 'ear', plural: 'ears', alternates: [] },\n  'fluid ounce': { short: 'fl oz', plural: 'fluid ounces', alternates: ['fluidounce', 'floz', 'fl-oz', 'fluid-ounce', 'fluid-ounces', 'fluidounces', 'fl ounce', 'fl ounces', 'fl-ounce', 'fl-ounces', 'fluid oz', 'fluid-oz'] }, // prettier-ignore\n  foot: { short: 'ft', plural: 'feet', alternates: ['ft.'] },\n  gallon: { short: 'gal', plural: 'gallons', alternates: ['gal.'] },\n  gram: { short: 'g', plural: 'grams', alternates: ['g.'] },\n  head: { short: 'head', plural: 'heads', alternates: [] },\n  inch: { short: 'in', plural: 'inches', alternates: ['in.'] },\n  kilogram: { short: 'kg', plural: 'kilograms', alternates: ['kg.'] },\n  large: { short: 'lg', plural: 'large', alternates: ['lg', 'lg.'] },\n  liter: { short: 'l', plural: 'liters', alternates: [] },\n  medium: { short: 'md', plural: 'medium', alternates: ['med', 'med.', 'md.'] },\n  meter: { short: 'm', plural: 'meters', alternates: ['m.'] },\n  milligram: { short: 'mg', plural: 'milligrams', alternates: ['mg.'] },\n  milliliter: { short: 'ml', plural: 'milliliters', alternates: ['mL', 'ml.', 'mL.'] },\n  millimeter: { short: 'mm', plural: 'millimeters', alternates: ['mm.'] },\n  ounce: { short: 'oz', plural: 'ounces', alternates: ['oz.'] },\n  pack: { short: 'pack', plural: 'packs', alternates: [] },\n  package: { short: 'pkg', plural: 'packages', alternates: ['pkg.', 'pkgs'] },\n  piece: { short: 'piece', plural: 'pieces', alternates: ['pcs', 'pcs.'] },\n  pinch: { short: 'pinch', plural: 'pinches', alternates: [] },\n  pint: { short: 'pt', plural: 'pints', alternates: ['pt.'] },\n  pound: { short: 'lb', plural: 'pounds', alternates: ['lb.', 'lbs', 'lbs.'] },\n  quart: { short: 'qt', plural: 'quarts', alternates: ['qt.', 'qts', 'qts.'] },\n  small: { short: 'sm', plural: 'small', alternates: ['sm.'] },\n  sprig: { short: 'sprig', plural: 'sprigs', alternates: [] },\n  stick: { short: 'stick', plural: 'sticks', alternates: [] },\n  tablespoon: { short: 'tbsp', plural: 'tablespoons', alternates: ['tbsp.', 'T', 'Tbsp.'] },\n  teaspoon: { short: 'tsp', plural: 'teaspoons', alternates: ['tsp.', 't'] },\n  yard: { short: 'yd', plural: 'yards', alternates: ['yd.', 'yds.'] },\n} satisfies UnitOfMeasureDefinitions;\n","/**\n * Removes falsy values from an array\n *\n * Originally from lodash: https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L6874\n */\nexport const compactStringArray = (array: string[]) => {\n  let index = -1;\n  const length = array.length;\n  let resIndex = 0;\n  const result: string[] = [];\n\n  while (++index < length) {\n    const value = array[index].trim();\n    // istanbul ignore else\n    if (value) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n};\n","import { numericQuantity } from 'numeric-quantity';\nimport {\n  defaultOptions,\n  firstWordRegEx,\n  forsRegEx,\n  ofRegEx,\n  rangeSeparatorRegEx,\n  unitsOfMeasure,\n} from './constants';\nimport type { Ingredient, ParseIngredientOptions, UnitOfMeasure } from './types';\nimport { compactStringArray } from './utils';\n\nconst newLineRegExp = /\\r?\\n/;\n\nconst addIdToUomDefinition = ([uom, def]: [string, UnitOfMeasure]) => ({ id: uom, ...def });\n\n/**\n * Parses a string into an array of recipe ingredient objects\n * @param ingText The ingredient text\n * @param options Configuration options\n */\nexport const parseIngredient = (\n  ingText: string,\n  options: ParseIngredientOptions = defaultOptions\n): Ingredient[] => {\n  const opts = { ...defaultOptions, ...options };\n  const mergedUOMs = { ...unitsOfMeasure, ...opts.additionalUOMs };\n  const uomArray = Object.entries(mergedUOMs).map(addIdToUomDefinition);\n  const uomArrayLength = uomArray.length;\n\n  return compactStringArray(ingText.split(newLineRegExp)).map(line => {\n    const oIng: Ingredient = {\n      quantity: null,\n      quantity2: null,\n      unitOfMeasureID: null,\n      unitOfMeasure: null,\n      description: '',\n      isGroupHeader: false,\n    };\n\n    // Check if the first character is numeric.\n    const nqResultFirstChar = numericQuantity(line.substring(0, 1));\n\n    if (isNaN(nqResultFirstChar)) {\n      // The first character is not numeric, so the entire line is the description.\n      oIng.description = line;\n\n      // If the line ends with \":\" or starts with \"For \", then it is assumed to be a group header.\n      if (oIng.description.endsWith(':') || forsRegEx.test(oIng.description)) {\n        oIng.isGroupHeader = true;\n      }\n    } else {\n      // The first character is numeric. See how many of the first seven\n      // constitute a single value. This will be `quantity`.\n      let lenNum = 6;\n      let nqResult = NaN;\n\n      while (lenNum > 0 && isNaN(nqResult)) {\n        nqResult = numericQuantity(line.substring(0, lenNum).trim());\n\n        if (nqResult > -1) {\n          oIng.quantity = nqResult;\n          oIng.description = line.substring(lenNum).trim();\n        }\n\n        lenNum--;\n      }\n    }\n\n    // Now check the description for a `quantity2` at the beginning.\n    // First we look for a dash, emdash, endash, \"to \", or \"or \" to\n    // indicate a range, then process the next seven characters just\n    // like we did for `quantity`.\n    const q2reMatch = rangeSeparatorRegEx.exec(oIng.description);\n    if (q2reMatch) {\n      const q2reMatchLen = q2reMatch[1].length;\n      const nqResultFirstChar = numericQuantity(oIng.description.substring(q2reMatchLen).trim()[0]);\n\n      if (!isNaN(nqResultFirstChar)) {\n        let lenNum = 7;\n        let nqResult = NaN;\n\n        while (--lenNum > 0 && isNaN(nqResult)) {\n          nqResult = numericQuantity(oIng.description.substring(q2reMatchLen, lenNum));\n\n          if (!isNaN(nqResult)) {\n            oIng.quantity2 = nqResult;\n            oIng.description = oIng.description.substring(lenNum).trim();\n          }\n        }\n      }\n    }\n\n    // Check for a known unit of measure\n    const firstWordREMatches = firstWordRegEx.exec(oIng.description);\n\n    if (firstWordREMatches) {\n      const firstWord = firstWordREMatches[1].replace(/\\s+/g, ' ');\n      const remainingDesc = (firstWordREMatches[2] ?? '').trim();\n      if (remainingDesc) {\n        let uom = '';\n        let uomID = '';\n        let i = -1;\n\n        while (++i < uomArrayLength && !uom) {\n          const { alternates, id, short, plural } = uomArray[i];\n          const versions = [...alternates, id, short, plural];\n          if (versions.includes(firstWord)) {\n            uom = firstWord;\n            uomID = id;\n          }\n        }\n\n        if (uom) {\n          oIng.unitOfMeasureID = uomID;\n          oIng.unitOfMeasure = opts.normalizeUOM ? uomID : uom;\n          oIng.description = remainingDesc;\n        }\n      }\n    }\n\n    if (!opts.allowLeadingOf && oIng.description.match(ofRegEx)) {\n      oIng.description = oIng.description.replace(ofRegEx, '');\n    }\n\n    return oIng;\n  });\n};\n"],"mappings":"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","names":["src_exports","__export","defaultOptions","firstWordRegEx","fors","forsRegEx","ofRegEx","ofs","parseIngredient","rangeSeparatorRegEx","rangeSeparatorWords","unitsOfMeasure","vulgarFractionToAsciiMap","numericRegex","numericRegexWithTrailingInvalid","vulgarFractionsRegex","romanNumeralValues","romanNumeralUnicodeToAsciiMap","romanNumeralUnicodeRegex","romanNumeralRegex","defaultOptions","parseRomanNumerals","romanNumerals","_a","_b","_c","_d","normalized","_m","rn","regexResult","thousands","hundreds","tens","ones","spaceThenSlashRegex","numericQuantity","quantity","options","finalResult","quantityAsString","vf","opts","__spreadValues","dash","ng1temp","ng2temp","numberGroup1","numberGroup2","roundingFactor","decimalValue","numerator","denominator","fractionArray","v","defaultOptions","fors","forsRegEx","rangeSeparatorWords","rangeSeparatorRegEx","firstWordRegEx","ofs","ofRegEx","unitsOfMeasure","compactStringArray","array","index","length","resIndex","result","value","newLineRegExp","addIdToUomDefinition","uom","def","parseIngredient","ingText","options","defaultOptions","opts","mergedUOMs","unitsOfMeasure","uomArray","uomArrayLength","compactStringArray","line","oIng","nqResultFirstChar","numericQuantity","forsRegEx","lenNum","nqResult","q2reMatch","rangeSeparatorRegEx","q2reMatchLen","firstWordREMatches","firstWordRegEx","firstWord","remainingDesc","uomID","i","alternates","id","short","plural","ofRegEx"]}