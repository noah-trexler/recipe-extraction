{"version":3,"sources":["../src/parseIngredient.ts","../src/constants.ts","../src/utils.ts"],"sourcesContent":["import { numericQuantity } from 'numeric-quantity';\nimport {\n  defaultOptions,\n  firstWordRegEx,\n  forsRegEx,\n  ofRegEx,\n  rangeSeparatorRegEx,\n  unitsOfMeasure,\n} from './constants';\nimport type { Ingredient, ParseIngredientOptions, UnitOfMeasure } from './types';\nimport { compactStringArray } from './utils';\n\nconst newLineRegExp = /\\r?\\n/;\n\nconst addIdToUomDefinition = ([uom, def]: [string, UnitOfMeasure]) => ({ id: uom, ...def });\n\n/**\n * Parses a string into an array of recipe ingredient objects\n * @param ingText The ingredient text\n * @param options Configuration options\n */\nexport const parseIngredient = (\n  ingText: string,\n  options: ParseIngredientOptions = defaultOptions\n): Ingredient[] => {\n  const opts = { ...defaultOptions, ...options };\n  const mergedUOMs = { ...unitsOfMeasure, ...opts.additionalUOMs };\n  const uomArray = Object.entries(mergedUOMs).map(addIdToUomDefinition);\n  const uomArrayLength = uomArray.length;\n\n  return compactStringArray(ingText.split(newLineRegExp)).map(line => {\n    const oIng: Ingredient = {\n      quantity: null,\n      quantity2: null,\n      unitOfMeasureID: null,\n      unitOfMeasure: null,\n      description: '',\n      isGroupHeader: false,\n    };\n\n    // Check if the first character is numeric.\n    const nqResultFirstChar = numericQuantity(line.substring(0, 1));\n\n    if (isNaN(nqResultFirstChar)) {\n      // The first character is not numeric, so the entire line is the description.\n      oIng.description = line;\n\n      // If the line ends with \":\" or starts with \"For \", then it is assumed to be a group header.\n      if (oIng.description.endsWith(':') || forsRegEx.test(oIng.description)) {\n        oIng.isGroupHeader = true;\n      }\n    } else {\n      // The first character is numeric. See how many of the first seven\n      // constitute a single value. This will be `quantity`.\n      let lenNum = 6;\n      let nqResult = NaN;\n\n      while (lenNum > 0 && isNaN(nqResult)) {\n        nqResult = numericQuantity(line.substring(0, lenNum).trim());\n\n        if (nqResult > -1) {\n          oIng.quantity = nqResult;\n          oIng.description = line.substring(lenNum).trim();\n        }\n\n        lenNum--;\n      }\n    }\n\n    // Now check the description for a `quantity2` at the beginning.\n    // First we look for a dash, emdash, endash, \"to \", or \"or \" to\n    // indicate a range, then process the next seven characters just\n    // like we did for `quantity`.\n    const q2reMatch = rangeSeparatorRegEx.exec(oIng.description);\n    if (q2reMatch) {\n      const q2reMatchLen = q2reMatch[1].length;\n      const nqResultFirstChar = numericQuantity(oIng.description.substring(q2reMatchLen).trim()[0]);\n\n      if (!isNaN(nqResultFirstChar)) {\n        let lenNum = 7;\n        let nqResult = NaN;\n\n        while (--lenNum > 0 && isNaN(nqResult)) {\n          nqResult = numericQuantity(oIng.description.substring(q2reMatchLen, lenNum));\n\n          if (!isNaN(nqResult)) {\n            oIng.quantity2 = nqResult;\n            oIng.description = oIng.description.substring(lenNum).trim();\n          }\n        }\n      }\n    }\n\n    // Check for a known unit of measure\n    const firstWordREMatches = firstWordRegEx.exec(oIng.description);\n\n    if (firstWordREMatches) {\n      const firstWord = firstWordREMatches[1].replace(/\\s+/g, ' ');\n      const remainingDesc = (firstWordREMatches[2] ?? '').trim();\n      if (remainingDesc) {\n        let uom = '';\n        let uomID = '';\n        let i = -1;\n\n        while (++i < uomArrayLength && !uom) {\n          const { alternates, id, short, plural } = uomArray[i];\n          const versions = [...alternates, id, short, plural];\n          if (versions.includes(firstWord)) {\n            uom = firstWord;\n            uomID = id;\n          }\n        }\n\n        if (uom) {\n          oIng.unitOfMeasureID = uomID;\n          oIng.unitOfMeasure = opts.normalizeUOM ? uomID : uom;\n          oIng.description = remainingDesc;\n        }\n      }\n    }\n\n    if (!opts.allowLeadingOf && oIng.description.match(ofRegEx)) {\n      oIng.description = oIng.description.replace(ofRegEx, '');\n    }\n\n    return oIng;\n  });\n};\n","import { ParseIngredientOptions, UnitOfMeasureDefinitions } from './types';\n\nexport const defaultOptions = {\n  additionalUOMs: {},\n  allowLeadingOf: false,\n  normalizeUOM: false,\n} satisfies Required<ParseIngredientOptions>;\n\nexport const fors = ['For'] as const;\nexport const forsRegEx = new RegExp(`^(?:${fors.join('|')})\\\\s`, 'i');\n\nexport const rangeSeparatorWords = ['or', 'to'] as const;\nexport const rangeSeparatorRegEx = new RegExp(\n  `^(-|–|—|(?:${rangeSeparatorWords.join('|')})\\\\s)`,\n  'i'\n);\n\nexport const firstWordRegEx = /^(fl(?:uid)?(?:\\s+|-)(?:oz|ounces?)|\\w+[-.]?)(.+)?/;\n\nexport const ofs = ['of'] as const;\nexport const ofRegEx = new RegExp(`^(?:${ofs.join('|')})\\\\s+`, 'i');\n\nexport const unitsOfMeasure = {\n  bag: { short: 'bag', plural: 'bags', alternates: [] },\n  box: { short: 'box', plural: 'boxes', alternates: [] },\n  bunch: { short: 'bunch', plural: 'bunches', alternates: [] },\n  can: { short: 'can', plural: 'cans', alternates: [] },\n  carton: { short: 'carton', plural: 'cartons', alternates: [] },\n  centimeter: { short: 'cm', plural: 'centimeters', alternates: ['cm.'] },\n  clove: { short: 'clove', plural: 'cloves', alternates: [] },\n  container: { short: 'container', plural: 'containers', alternates: [] },\n  cup: { short: 'c', plural: 'cups', alternates: ['c.', 'C'] },\n  dash: { short: 'dash', plural: 'dashes', alternates: [] },\n  drop: { short: 'drop', plural: 'drops', alternates: [] },\n  ear: { short: 'ear', plural: 'ears', alternates: [] },\n  'fluid ounce': { short: 'fl oz', plural: 'fluid ounces', alternates: ['fluidounce', 'floz', 'fl-oz', 'fluid-ounce', 'fluid-ounces', 'fluidounces', 'fl ounce', 'fl ounces', 'fl-ounce', 'fl-ounces', 'fluid oz', 'fluid-oz'] }, // prettier-ignore\n  foot: { short: 'ft', plural: 'feet', alternates: ['ft.'] },\n  gallon: { short: 'gal', plural: 'gallons', alternates: ['gal.'] },\n  gram: { short: 'g', plural: 'grams', alternates: ['g.'] },\n  head: { short: 'head', plural: 'heads', alternates: [] },\n  inch: { short: 'in', plural: 'inches', alternates: ['in.'] },\n  kilogram: { short: 'kg', plural: 'kilograms', alternates: ['kg.'] },\n  large: { short: 'lg', plural: 'large', alternates: ['lg', 'lg.'] },\n  liter: { short: 'l', plural: 'liters', alternates: [] },\n  medium: { short: 'md', plural: 'medium', alternates: ['med', 'med.', 'md.'] },\n  meter: { short: 'm', plural: 'meters', alternates: ['m.'] },\n  milligram: { short: 'mg', plural: 'milligrams', alternates: ['mg.'] },\n  milliliter: { short: 'ml', plural: 'milliliters', alternates: ['mL', 'ml.', 'mL.'] },\n  millimeter: { short: 'mm', plural: 'millimeters', alternates: ['mm.'] },\n  ounce: { short: 'oz', plural: 'ounces', alternates: ['oz.'] },\n  pack: { short: 'pack', plural: 'packs', alternates: [] },\n  package: { short: 'pkg', plural: 'packages', alternates: ['pkg.', 'pkgs'] },\n  piece: { short: 'piece', plural: 'pieces', alternates: ['pcs', 'pcs.'] },\n  pinch: { short: 'pinch', plural: 'pinches', alternates: [] },\n  pint: { short: 'pt', plural: 'pints', alternates: ['pt.'] },\n  pound: { short: 'lb', plural: 'pounds', alternates: ['lb.', 'lbs', 'lbs.'] },\n  quart: { short: 'qt', plural: 'quarts', alternates: ['qt.', 'qts', 'qts.'] },\n  small: { short: 'sm', plural: 'small', alternates: ['sm.'] },\n  sprig: { short: 'sprig', plural: 'sprigs', alternates: [] },\n  stick: { short: 'stick', plural: 'sticks', alternates: [] },\n  tablespoon: { short: 'tbsp', plural: 'tablespoons', alternates: ['tbsp.', 'T', 'Tbsp.'] },\n  teaspoon: { short: 'tsp', plural: 'teaspoons', alternates: ['tsp.', 't'] },\n  yard: { short: 'yd', plural: 'yards', alternates: ['yd.', 'yds.'] },\n} satisfies UnitOfMeasureDefinitions;\n","/**\n * Removes falsy values from an array\n *\n * Originally from lodash: https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L6874\n */\nexport const compactStringArray = (array: string[]) => {\n  let index = -1;\n  const length = array.length;\n  let resIndex = 0;\n  const result: string[] = [];\n\n  while (++index < length) {\n    const value = array[index].trim();\n    // istanbul ignore else\n    if (value) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n};\n"],"mappings":"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","names":["numericQuantity","defaultOptions","fors","forsRegEx","rangeSeparatorWords","rangeSeparatorRegEx","firstWordRegEx","ofs","ofRegEx","unitsOfMeasure","compactStringArray","array","index","length","resIndex","result","value","newLineRegExp","addIdToUomDefinition","uom","def","parseIngredient","ingText","options","defaultOptions","opts","mergedUOMs","unitsOfMeasure","uomArray","uomArrayLength","compactStringArray","line","oIng","nqResultFirstChar","numericQuantity","forsRegEx","lenNum","nqResult","q2reMatch","rangeSeparatorRegEx","q2reMatchLen","firstWordREMatches","firstWordRegEx","firstWord","remainingDesc","uomID","i","alternates","id","short","plural","ofRegEx"]}