interface NumericQuantityOptions {
    /**
     * Round the result to this many decimal places. Defaults to 3; must
     * be greater than or equal to zero.
     *
     * @default 3
     */
    round?: number | false;
    /**
     * Allow and ignore trailing invalid characters _à la_ `parseFloat`.
     *
     * @default false
     */
    allowTrailingInvalid?: boolean;
    /**
     * Attempt to parse Roman numerals if Arabic numeral parsing fails.
     *
     * @default false
     */
    romanNumerals?: boolean;
}
/**
 * Unicode vulgar fraction code points
 */
type VulgarFraction = '¼' | '½' | '¾' | '⅐' | '⅑' | '⅒' | '⅓' | '⅔' | '⅕' | '⅖' | '⅗' | '⅘' | '⅙' | '⅚' | '⅛' | '⅜' | '⅝' | '⅞' | '⅟';
/**
 * Allowable Roman numeral characters (ASCII, uppercase only)
 */
type RomanNumeralAscii = 'I' | 'V' | 'X' | 'L' | 'C' | 'D' | 'M';
/**
 * Unicode Roman numeral code points (uppercase and lowercase,
 * representing 1-12, 50, 100, 500, and 1000)
 */
type RomanNumeralUnicode = 'Ⅰ' | 'Ⅱ' | 'Ⅲ' | 'Ⅳ' | 'Ⅴ' | 'Ⅵ' | 'Ⅶ' | 'Ⅷ' | 'Ⅸ' | 'Ⅹ' | 'Ⅺ' | 'Ⅻ' | 'Ⅼ' | 'Ⅽ' | 'Ⅾ' | 'Ⅿ' | 'ⅰ' | 'ⅱ' | 'ⅲ' | 'ⅳ' | 'ⅴ' | 'ⅵ' | 'ⅶ' | 'ⅷ' | 'ⅸ' | 'ⅹ' | 'ⅺ' | 'ⅻ' | 'ⅼ' | 'ⅽ' | 'ⅾ' | 'ⅿ';
/**
 * Union of ASCII and Unicode Roman numeral characters/code points
 */
type RomanNumeral = RomanNumeralAscii | RomanNumeralUnicode;

/**
 * Map of Unicode fraction code points to their ASCII equivalents
 */
declare const vulgarFractionToAsciiMap: Record<VulgarFraction, string>;
/**
 * Captures the individual elements of a numeric string.
 *
 * Capture groups:
 *
 *     +=====+====================+========================+
 *     |  #  |    Description     |        Example         |
 *     +=====+====================+========================+
 *     |  0  |  entire string     |  "2 1/3" from "2 1/3"  |
 *     +-----+--------------------+------------------------+
 *     |  1  |  "negative" dash   |  "-" from "-2 1/3"     |
 *     +-----+--------------------+------------------------+
 *     |  2  |  the whole number  |  "2" from "2 1/3"      |
 *     |     |  - OR -            |                        |
 *     |     |  the numerator     |  "1" from "1/3"        |
 *     |     +                    +                        |
 *     | (This may include comma/underscore separators)    |
 *     +-----+--------------------+------------------------+
 *     |  3  |  entire fraction   |  " 1/3" from "2 1/3"   |
 *     |     |  - OR -            |                        |
 *     |     |  decimal portion   |  ".33" from "2.33"     |
 *     |     |  - OR -            |                        |
 *     |     |  denominator       |  "/3" from "1/3"       |
 *     +=====+====================+========================+
 *
 * @example
 *     numericRegex.exec("1")     // [ "1",     "1", null,   null ]
 *     numericRegex.exec("1.23")  // [ "1.23",  "1", ".23",  null ]
 *     numericRegex.exec("1 2/3") // [ "1 2/3", "1", " 2/3", " 2" ]
 *     numericRegex.exec("2/3")   // [ "2/3",   "2", "/3",   null ]
 *     numericRegex.exec("2 / 3") // [ "2 / 3", "2", "/ 3",  null ]
 */
declare const numericRegex: RegExp;
/**
 * Same as `numericRegex`, but allows/ignores trailing invalid characters.
 */
declare const numericRegexWithTrailingInvalid: RegExp;
/**
 * Captures any Unicode vulgar fractions
 */
declare const vulgarFractionsRegex: RegExp;
declare const romanNumeralValues: {
    MMM: number;
    MM: number;
    M: number;
    CM: number;
    DCCC: number;
    DCC: number;
    DC: number;
    D: number;
    CD: number;
    CCC: number;
    CC: number;
    C: number;
    XC: number;
    LXXX: number;
    LXX: number;
    LX: number;
    L: number;
    XL: number;
    XXX: number;
    XX: number;
    XII: number;
    XI: number;
    X: number;
    IX: number;
    VIII: number;
    VII: number;
    VI: number;
    V: number;
    IV: number;
    III: number;
    II: number;
    I: number;
};
/**
 * Map of Unicode Roman numeral code points to their ASCII equivalents
 */
declare const romanNumeralUnicodeToAsciiMap: Record<RomanNumeralUnicode, keyof typeof romanNumeralValues>;
/**
 * Captures all Unicode Roman numeral code points
 */
declare const romanNumeralUnicodeRegex: RegExp;
/**
 * Captures a valid Roman numeral sequence
 *
 * Capture groups:
 *
 *     +=====+=================+==========================+
 *     |  #  |   Description   |         Example          |
 *     +=====+=================+==========================+
 *     |  0  |  Entire string  |  "MCCXIV" from "MCCXIV"  |
 *     +-----+-----------------+--------------------------+
 *     |  1  |  Thousands      |  "M" from "MCCXIV"       |
 *     +-----+-----------------+--------------------------+
 *     |  2  |  Hundreds       |  "CC" from "MCCXIV"      |
 *     +-----+-----------------+--------------------------+
 *     |  3  |  Tens           |  "X" from "MCCXIV"       |
 *     +-----+-----------------+--------------------------+
 *     |  4  |  Ones           |  "IV" from "MCCXIV"      |
 *     +=====+=================+==========================+
 *
 * @example
 *     romanNumeralRegex.exec("M")      // [      "M", "M",   "",  "",   "" ]
 *     romanNumeralRegex.exec("XII")    // [    "XII",  "",   "", "X", "II" ]
 *     romanNumeralRegex.exec("MCCXIV") // [ "MCCXIV", "M", "CC", "X", "IV" ]
 */
declare const romanNumeralRegex: RegExp;
declare const defaultOptions: {
    round: number;
    allowTrailingInvalid: false;
    romanNumerals: false;
};

/**
 * Converts a string to a number, like an enhanced version of `parseFloat`.
 *
 * The string can include mixed numbers, vulgar fractions, or Roman numerals.
 */
declare const numericQuantity: (quantity: string | number, options?: NumericQuantityOptions) => number;

/**
 * Converts a string of Roman numerals to a number, like `parseInt`
 * for Roman numerals. Uses modern, strict rules (only 1 to 3999).
 *
 * The string can include ASCII representations of Roman numerals
 * or Unicode Roman numeral code points (`U+2160` through `U+217F`).
 */
declare const parseRomanNumerals: (romanNumerals: string) => number;

export { NumericQuantityOptions, RomanNumeral, RomanNumeralAscii, RomanNumeralUnicode, VulgarFraction, defaultOptions, numericQuantity, numericRegex, numericRegexWithTrailingInvalid, parseRomanNumerals, romanNumeralRegex, romanNumeralUnicodeRegex, romanNumeralUnicodeToAsciiMap, romanNumeralValues, vulgarFractionToAsciiMap, vulgarFractionsRegex };
